# 创建一个窗口

+ 在开始创建令人惊叹的图形之前，我们需要做的第一件事是创建一个 `OpenGL` 上下文和一个要绘制的应用程序窗口。但是，这些操作是特定于每个操作系统的， `OpenGL` 有意尝试从这些操作中抽象出来。这意味着我们必须自己创建一个窗口、定义一个上下文并处理用户输入。

+ 幸运的是，有相当多的库可以提供我们所寻求的功能，其中一些是专门针对 `OpenGL` 的。这些库为我们节省了所有操作系统特定的工作，并为我们提供了一个窗口和一个用于渲染的 `OpenGL` 上下文。一些更流行的库是 `GLUT` 、 `SDL` 、 `SFML` 和 `GLFW` 。在 `LearnOpenGL` 中，我们将使用 `GLFW` 。随意使用任何其他库，大多数的设置与 `GLFW` 的设置类似。

## GLFW

+ `GLFW` 是一个用 `C` 语言编写的库，专门针对 `OpenGL` 。 `GLFW` 为我们提供了在屏幕上渲染内容所需的基本必需品。它允许我们创建 `OpenGL` 上下文、定义窗口参数并处理用户输入，这足以满足我们的目的。

+ 本章和下一章的重点是让 `GLFW` 启动并运行，确保它正确创建一个 `OpenGL` 上下文，并显示一个简单的窗口供我们使用。本章将逐步介绍检索、构建和链接 `GLFW` 库的方法。截至撰写本文时，我们将使用 `Microsoft Visual Studio 2019 IDE` （请注意，该过程在更新的 `Visual Studio` 版本上是相同的）。如果您不使用 `Visual Studio` （或旧版本），请不要担心，大多数其他 `IDE` 上的过程都类似。

## 构建GLFW

+ `GLFW` 可以从其网页的下载页面获取。 `GLFW` 已经为 `Visual Studio 2012` 到 `2019` 年提供了预编译的二进制文件和头文件，但为了完整起见，我们将自己从源代码编译 `GLFW` 。这是为了让您体验一下自己编译开源库的过程，因为并非每个库都有可用的预编译二进制文件。那么我们来下载源码包。

+ 我们将把所有库构建为 `64` 位二进制文​​件，因此如果您使用其预编译的二进制文件，请确保获取 `64` 位二进制文​​件。

+ 下载源包后，将其解压缩并打开其内容。我们只对以下几项感兴趣：

  * 编译生成的库。

  * 包含文件夹。

+ 从源代码编译库可确保生成的库完全适合您的 `CPU`/操作系统，但并不总是提供豪华的预编译二进制文件（有时，预编译二进制文件不适用于您的系统）。然而，向开放世界提供源代码的问题在于，并非每个人都使用相同的 IDE 或构建系统来开发其应用程序，这意味着提供的项目/解决方案文件可能与其他人的设置不兼容。因此，人们必须使用给定的 `.c/.cpp` 和 `.h/.hpp` 文件设置自己的项目/解决方案，这很麻烦。正是出于这些原因，出现了一个名为 `CMake` 的工具。

## CMake

+ `CMake` 是一种工具，可以使用预定义的 `CMake` 脚本从源代码文件集合中生成用户选择的项目/解决方案文件（例如 `Visual Studio、Code::Blocks、Eclipse` ）。这使我们能够从 `GLFW` 的源包生成 `Visual Studio 2019` 项目文件，我们可以用它来编译库。首先我们需要下载并安装 `CMake` ，可以在他们的下载页面下载。

+ 安装 `CMake` 后，您可以选择从命令行或通过 `GUI` 运行 `CMake` 。因为我们不想让事情变得过于复杂，所以我们将使用 `GUI` 。 `CMake` 需要一个源代码文件夹和一个二进制文件的目标文件夹。对于源代码文件夹，我们将选择下载的 GLFW 源包的根文件夹，对于构建文件夹，我们将创建一个新目录 build，然后选择该目录。

+ 设置源文件夹和目标文件夹后，单击 `Configure` 按钮，以便 `CMake` 可以读取所需的设置和源代码。然后，我们必须为项目选择生成器，由于我们使用的是 `Visual Studio 2019` ，我们将选择 `Visual Studio 16` 选项（ `Visual Studio 2019` 也称为 `Visual Studio 16` ）。然后， `CMake` 将显示可能的构建选项来配置生成的库。我们可以将它们保留为默认值，然后再次单击 `Configure` 来存储设置。设置完成后，我们单击 `Generate` ，生成的项目文件将在您的 `build` 文件夹中生成。

## 汇编

+ 现在可以在 `build` 文件夹中找到名为 `GLFW.sln` 的文件，我们可以使用 `Visual Studio 2019` 打开它。由于 `CMake` 生成的项目文件已包含正确的配置设置，因此我们只需构建解决方案即可。 `CMake` 应该自动配置解决方案，以便将其编译为 `64` 位库；现在点击构建解决方案。这将为我们提供一个已编译的库文件，可以在名为 `glfw3.lib` 的 `build/src/Debug` 中找到该文件。

+ 生成库后，我们需要确保 `IDE` 知道在哪里可以找到库以及 `OpenGL` 程序的包含文件。执行此操作有两种常见方法：

    * 1. 我们找到 `IDE`/编译器的 `/lib` 和 `/include` 文件夹，并将 `GLFW` 的 `include` 文件夹的内容添加到 `IDE` 的 `/include` 文件夹中，类似地将 `glfw3.lib` 添加到 `IDE` 的 `/lib` 文件夹中。这可行，但不是推荐的方法。跟踪您的库和包含文件非常困难，并且新安装的 `IDE`/编译器会导致您必须重新执行此过程。

    * 2. 另一种方法（推荐）是在您选择的位置创建一组新目录，其中包含来自第三方库的所有头文件/库，您可以从 `IDE`/编译器引用这些头文件/库。例如，您可以创建一个包含 `Libs` 和 `Include` 文件夹的文件夹，我们分别在其中存储 `OpenGL` 项目的所有库文件和头文件。现在，所有第三方库都组织在一个位置（可以在多台计算机之间共享）。然而，要求是每次创建新项目时，我们都必须告诉 `IDE` 在哪里可以找到这些目录。

+ 一旦所需的文件存储在您选择的位置，我们就可以开始创建我们的第一个 `OpenGL GLFW` 项目。

## 我们的第一个项目

+ 首先，让我们打开 `Visual Studio` 并创建一个新项目。如果给出多个选项，请选择 `C++` 并采用 `Empty Project` （不要忘记为您的项目指定合适的名称）。由于我们将在 `64` 位中进行所有操作，并且项目默认为 `32` 位，因此我们需要将 “调试” 旁边顶部的下拉列表从 `x86` 更改为 `x64` ：

+ 完成后，我们现在就有了一个工作区来创建我们的第一个 `OpenGL` 应用程序！

## 链接

+ 为了让项目使用 `GLFW` ，我们需要将库与我们的项目链接起来。这可以通过在链接器设置中指定我们要使用 `glfw3.lib` 来完成，但我们的项目尚不知道在哪里找到 `glfw3.lib` ，因为我们将第三方库存储在不同的目录中。因此，我们需要首先将此目录添加到项目中。

+ 我们可以告诉 `IDE` 在需要查找库和包含文件时考虑此目录。右键单击解决方案资源管理器中的项目名称，然后转到 `VC++ Directories` ，如下图所示：

+ 从那里开始，您可以添加自己的目录，让项目知道在哪里搜索。这可以通过手动将其插入文本或单击适当的位置字符串并选择 <Edit..> 选项来完成。对 `Library Directories` 和 `Include Directories` 执行此操作：

+ 您可以在此处添加任意数量的额外目录，从那时起， `IDE` 在搜索库和头文件时也会搜索这些目录。一旦包含了 `GLFW` 中的 `Include` 文件夹，您就可以通过包含 <GLFW/..> 找到 `GLFW` 的所有头文件。这同样适用于库目录。

+ 由于 `VS` 现在可以找到所有必需的文件，我们最终可以通过转到 `Linker` 选项卡和 `Input` 将 `GLFW` 链接到项目：

+ 要链接到库，您必须向链接器指定库的名称。由于库名称为 `glfw3.lib` ，我们将其添加到 `Additional Dependencies` 字段（手动或使用 <Edit..> 选项），并且从那时起，我们在编译时将链接到 `GLFW` 。除了 `GLFW` 之外，我们还应该添加一个到 `OpenGL` 库的链接条目，但这可能因操作系统而异：

## Windows 上的 OpenGL 库

+ 如果您使用的是 `Windows` ，则 `OpenGL` 库 `opengl32.lib` 会随 `Microsoft SDK` 一起提供，该库在您安装 `Visual Studio` 时默认安装。由于本章使用 `VS` 编译器并且是在 `Windows` 上，因此我们将 `opengl32.lib` 添加到链接器设置中。请注意， `OpenGL` 库的 `64` 位等效项称为 `opengl32.lib` ，就像 `32` 位等效项一样，这是一个有点不幸的名称。

## Linux 上的 OpenGL 库

+ 在 `Linux` 系统上，您需要通过将 `-lGL` 添加到链接器设置来链接到 `libGL.so` 库。如果找不到该库，您可能需要安装任何 `Mesa、NVidia` 或 `AMD` 开发包。

+ 然后，将 `GLFW` 和 `OpenGL` 库添加到链接器设置后，您可以包含 `GLFW` 的头文件，如下所示：

    ```C++
    #include <GLFW/glfw3.h>
    ```

+ 对于使用 `GCC` 编译的 `Linux` 用户，以下命令行选项可能会帮助您编译项目： `-lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi -ldl` 。不正确链接相应的库会产生许多未定义的引用错误。

+ `GLFW` 的设置和配置到此结束。

## GLAD

+ 我们还没有完全做到这一点，因为我们还需要做另一件事。因为 `OpenGL` 实际上只是一个标准/规范，所以由驱动程序制造商将规范实施到特定显卡支持的驱动程序。由于 `OpenGL` 驱动程序有很多不同的版本，其大部分函数的位置在编译时是未知的，需要在运行时查询。然后，开发人员的任务是检索他/她需要的函数的位置并将它们存储在函数指针中以供以后使用。检索这些位置是特定于操作系统的。在 `Windows` 中，它看起来像这样：

    ```C++
    // define the function's prototype
    typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
    // find the function and assign it to a function pointer
    GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
    // function can now be called as normal
    unsigned int buffer;
    glGenBuffers(1, &buffer);
    ```

+ 正如您所看到的，代码看起来很复杂，并且对于您可能需要但尚未声明的每个函数执行此操作是一个繁琐的过程。值得庆幸的是，也有用于此目的的库，其中 `GLAD` 是一个流行且最新的库。

## 设置 GLAD

+ `GLAD` 是一个开源库，可以管理我们谈到的所有繁琐的工作。 `GLAD` 的配置设置与大多数常见的开源库略有不同。 `GLAD` 使用一个 `Web` 服务，我们可以告诉 `GLAD` 我们想要为哪个版本的 `OpenGL` 定义并根据该版本加载所有相关的 `OpenGL` 函数。

+ 转到 `GLAD Web` 服务，确保语言设置为 `C++` ，然后在 `API` 部分选择至少 `3.3` 的 `OpenGL` 版本（这就是我们将使用的；更高版本也可以）。还要确保配置文件设置为 “核心” 并且勾选 “生成加载程序” 选项。忽略扩展名（暂时）并单击 “生成” 以生成生成的库文件。

+ `GLAD` 现在应该已经为您提供了一个包含两个包含文件夹和一个 `glad.c` 文件的 `zip` 文件。将两个包含文件夹（ `glad` 和 `KHR` ）复制到您的包含目录中（或添加指向这些文件夹的额外项目），并将 `glad.c` 文件添加到您的项目中。

+ 完成前面的步骤后，您应该能够在文件上方添加以下 `include` 指令：

    ```C++
    #include <glad/glad.h> 
    ```

+ 点击编译按钮不应该给你任何错误，此时我们准备进入下一章，我们将讨论如何实际使用 `GLFW` 和 `GLAD` 来配置 `OpenGL` 上下文并生成一个窗口。请务必检查所有包含目录和库目录是否正确，并且链接器设置中的库名称是否与相应的库匹配。

## 其他资源

+ `GLFW` ：窗口指南：有关设置和配置 `GLFW` 窗口的官方 `GLFW` 指南。

+ 构建应用程序：提供有关应用程序的编译/链接过程的重要信息以及可能出现的大量可能错误（以及解决方案）。

+ `GLFW with Code::Blocks` ：在 `Code::Blocks IDE` 中构建 `GLFW` 。

+ 行 `CMake` ：如何在 `Windows` 和 `Linux` 上运行 `CMake` 的简短概述。

+ 在 `Linux` 下编写构建系统：`Wouter Verholst` 编写的自动工具教程，介绍如何在 `Linux` 中编写构建系统。

+ `Polytonic/Glitter` ：一个简单的样板项目，预配置了所有相关库；如果您想要一个示例项目，而无需自己编译所有库，那么这非常适合。