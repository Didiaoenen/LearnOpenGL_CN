# OpenGL

+ 在开始我们的旅程之前，我们应该首先定义 `OpenGL` 到底是什么。 OpenGL主要被认为是一个 `API` （应用程序编程接口），它为我们提供了大量可用于操作图形和图像的函数。然而， `OpenGL` 本身并不是一个 `API` ，而仅仅是一个规范，由 `Khronos Group` 开发和维护。

+ `OpenGL` 规范准确地指定了每个函数的结果/输出应该是什么以及它应该如何执行。然后，由实现该规范的开发人员提出该函数应如何运行的解决方案。由于 `OpenGL` 规范没有给出实现细节，因此 `OpenGL` 的实际开发版本可以有不同的实现，只要它们的结果符合规范（因此对用户来说是相同的）。

+ 开发实际 `OpenGL` 库的人通常是显卡制造商。您购买的每张显卡都支持特定版本的 `OpenGL` ，这些版本是专门为该卡（系列）开发的 `OpenGL` 版本。当使用 `Apple` 系统时， `OpenGL` 库由 `Apple` 自己维护，而在 Linux 下，存在图形供应商的版本和爱好者对这些库的改编的组合。这也意味着每当 `OpenGL` 显示出不应该出现的奇怪行为时，这很可能是显卡制造商（或开发/维护该库的任何人）的错误。

+ 由于大多数实现都是由显卡制造商构建的，因此每当实现中出现错误时，通常可以通过更新显卡驱动程序来解决；这些驱动程序包括您的卡支持的最新版本的 `OpenGL` 。这就是为什么总是建议偶尔更新图形驱动程序的原因之一。

+ `Khronos` 公开托管所有 `OpenGL` 版本的所有规范文档。有兴趣的读者可以在这里找到 3.3 版的 `OpenGL` 规范（我们将使用它），如果您想深入了解 `OpenGL` 的细节（请注意它们大多只是描述结果而不是实现），这是一本很好的读物。这些规范还为查找其功能的确切运作方式提供了很好的参考。

## 核心配置文件与立即模式

+ 在过去，使用 `OpenGL` 意味着以立即模式（通常称为固定功能管道）进行开发，这是一种易于使用的图形绘制方法。 `OpenGL` 的大部分功能都隐藏在库中，开发人员对 `OpenGL` 如何进行计算没有太多控制权。开发人员最终渴望更大的灵活性，随着时间的推移，规范变得更加灵活；开发人员可以更好地控制他们的图形。立即模式确实易于使用和理解，但效率也极低。因此，该规范从 3.2 版开始弃用立即模式功能，并开始激励开发人员在 `OpenGL` 的核心配置模式下进行开发，该模式是 `OpenGL` 规范的一个部分，删除了所有旧的弃用功能。

+ 当使用 `OpenGL` 的核心配置文件时， `OpenGL` 迫使我们使用现代实践。每当我们尝试使用 `OpenGL` 已弃用的函数之一时， `OpenGL` 都会引发错误并停止绘制。学习现代方法的优点是非常灵活和高效。然而，它也更难学习。立即模式从 `OpenGL` 执行的实际操作中抽象了很多，虽然很容易学习，但很难掌握 `OpenGL` 的实际操作方式。现代方法要求开发人员真正理解 `OpenGL` 和图形编程，虽然有点困难，但它提供了更大的灵活性、更高的效率，最重要的是：更好地理解图形编程。

+ 这也是本书面向核心配置文件 `OpenGL` 3.3 版本的原因。虽然比较困难，但是非常值得付出努力。

+ 截至今天，更高版本的 `OpenGL` 可供选择（在撰写本文时为 4.6），此时您可能会问： `OpenGL` 4.6 已经出来了，为什么我还要学习 `OpenGL` 3.3？这个问题的答案相对简单。从 3.3 开始的所有未来版本的 `OpenGL` 都在不改变 `OpenGL` 核心机制的情况下为 `OpenGL` 添加了额外的有用功能；新版本只是引入了稍微更有效或更有用的方法来完成相同的任务。结果是所有概念和技术在现代 `OpenGL` 版本中都保持不变，因此学习 `OpenGL` 3.3 是完全有效的。只要您准备好和/或更有经验，您就可以轻松使用最新 `OpenGL` 版本中的特定功能。

+ 使用最新版本 `OpenGL` 的功能时，只有最现代的显卡才能运行您的应用程序。这通常就是为什么大多数开发人员通常以较低版本的 `OpenGL` 为目标并选择性地启用较高版本功能的原因。

+ 在某些章节中，您会发现更多现代功能，这些功能已被记录下来。

## 扩展

+ `OpenGL` 的一个重要特性是它对扩展的支持。每当图形公司提出新技术或新的大型渲染优化时，通常会在驱动程序中实现的扩展中找到它。如果应用程序运行的硬件支持此类扩展，则开发人员可以使用扩展提供的功能来获得更高级或更高效的图形。这样，图形开发人员仍然可以使用这些新的渲染技术，而无需等待 `OpenGL` 在其未来版本中包含该功能，只需检查显卡是否支持该扩展即可。通常，当扩展流行或非常有用时，它最终会成为未来 `OpenGL` 版本的一部分。

+ 开发人员在使用这些扩展之前必须查询是否可用（或使用 `OpenGL` 扩展库）。这使得开发人员可以根据扩展是否可用来做得更好或更高效：

    ```C++
    if(GL_ARB_extension_name)
    {
        // Do cool new and modern stuff supported by hardware
    }
    else
    {
        // Extension not supported: do it the old way
    }
    ```

+ 对于 `OpenGL` 3.3 版，我们很少需要对大多数技术进行扩展，但只要有必要，就会提供正确的说明。

## 状态机

+ `OpenGL` 本身就是一个大型状态机：定义 `OpenGL` 当前应如何操作的变量集合。 `OpenGL` 的状态通常称为 `OpenGL` 上下文。使用 `OpenGL` 时，我们经常通过设置一些选项、操作一些缓冲区来更改其状态，然后使用当前上下文进行渲染。

+ 例如，每当我们告诉 `OpenGL` 我们现在想要绘制直线而不是三角形时，我们都会通过更改一些设置 `OpenGL` 应如何绘制的上下文变量来更改 `OpenGL` 的状态。一旦我们通过告诉 `OpenGL` 它应该绘制线条来更改上下文，下一个绘制命令现在将绘制线条而不是三角形。

+ 在 `OpenGL` 中工作时，我们会遇到几个更改上下文的状态更改函数，以及几个基于 `OpenGL` 当前状态执行某些操作的状态使用函数。只要您记住 `OpenGL` 基本上是一个大型状态机，它的大部分功能就会更有意义。

## 对象

+ `OpenGL` 库是用 `C` 语言编写的，并允许使用其他语言进行许多派生，但其核心仍然是 `C` 库。由于许多 `C` 语言结构不能很好地转换为其他高级语言，因此 `OpenGL` 在开发时考虑了多种抽象。这些抽象之一是 `OpenGL` 中的对象。

+ `OpenGL` 中的对象是代表 `OpenGL` 状态子集的选项集合。例如，我们可以有一个代表绘图窗口设置的对象；然后我们可以设置它的大小、支持多少种颜色等等。人们可以将一个对象可视化为类似 `C` 的结构：

    ```C++
    struct object_name {
        float  option1;
        int    option2;
        char[] name;
    };
    ```

+ 每当我们想要使用对象时，它通常看起来像这样（ `OpenGL` 的上下文可视化为一个大结构）：

    ```C++
    // The State of OpenGL
    struct OpenGL_Context {
        ...
        object_name* object_Window_Target;
        ...  	
    };
    ```

    ```C++
    // create object
    unsigned int objectId = 0;
    glGenObject(1, &objectId);
    // bind/assign object to context
    glBindObject(GL_WINDOW_TARGET, objectId);
    // set options of object currently bound to GL_WINDOW_TARGET
    glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
    glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
    // set context target back to default
    glBindObject(GL_WINDOW_TARGET, 0);
    ```

+ 这段小代码是您在使用 `OpenGL` 时经常看到的工作流程。我们首先创建一个对象并将其引用存储为 `id` （真实对象的数据存储在幕后）。然后我们将该对象（使用其 `id` ）绑定到上下文的目标位置（示例窗口对象目标的位置定义为 `GL_WINDOW_TARGET` ）。接下来我们设置窗口选项，最后通过将窗口目标的当前对象 `id` 设置为 `0` 来取消绑定对象。我们设置的选项存储在 `objectId` 引用的对象中，并在我们将对象绑定回 `GL_WINDOW_TARGET` 后立即恢复。

+ 到目前为止提供的代码示例只是 `OpenGL` 操作方式的近似值；在整本书中，你会遇到足够多的实际例子。

+ 使用这些对象的好处在于，我们可以在应用程序中定义多个对象，设置它们的选项，并且每当我们启动使用 `OpenGL` 状态的操作时，我们都会将对象与我们的首选设置绑定。例如，有些对象充当 3D 模型数据的容器对象（房屋或角色），每当我们想要绘制其中一个对象时，我们都会绑定包含我们想要绘制的模型数据的对象（我们首先为这些对象创建并设置选项）。拥有多个对象允许我们指定许多模型，每当我们想要绘制特定模型时，我们只需在绘制之前绑定相应的对象即可，而无需再次设置其所有选项。

## 让我们开始吧

+ 现在您已经了解了一些关于 `OpenGL` 作为规范和库的知识、 `OpenGL` 的大致工作原理以及 `OpenGL` 使用的一些自定义技巧。如果您没有全部了解，请不要担心；在整本书中，我们将逐步完成每个步骤，您将看到足够的示例来真正掌握 `OpenGL` 。

## 其他资源

+ `opengl.org` ： `OpenGL` 官方网站。

+ `OpenGL` 注册表：托管所有 `OpenGL` 版本的 `OpenGL` 规范和扩展。